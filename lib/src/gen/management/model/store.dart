//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

// ignore_for_file: unused_element
import 'package:built_collection/built_collection.dart';
import 'package:adyen_api/src/gen/management/model/links.dart';
import 'package:adyen_api/src/gen/management/model/sub_merchant_data.dart';
import 'package:adyen_api/src/gen/management/model/localized_information.dart';
import 'package:adyen_api/src/gen/management/model/store_split_configuration.dart';
import 'package:adyen_api/src/gen/management/model/store_location.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';

part 'store.g.dart';

/// Store
///
/// Properties:
/// * [links] - Reference to resources connected with the store.
/// * [address] - The address of the store.
/// * [businessLineIds] - The unique identifiers of the [business lines](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/businesslines__resParam_id) that the store is associated with.  If not specified, the business line of the merchant account is used. Required when there are multiple business lines under the merchant account.
/// * [description] - The description of the store.
/// * [externalReferenceId] - The unique identifier of the store, used by certain payment methods and tax authorities.  Required for CNPJ in Brazil, in the format 00.000.000/0000-00 separated by dots, slashes, hyphens, or without separators.  Optional for SIRET in France, up to 14 digits.  Optional for Zip in Australia, up to 50 digits.  
/// * [id] - The unique identifier of the store. This value is generated by Adyen.
/// * [localizedInformation] - The localized information of the store.
/// * [merchantId] - The unique identifier of the merchant account that the store belongs to.
/// * [phoneNumber] - The phone number of the store, including '+' and country code in the [E.164](https://en.wikipedia.org/wiki/E.164) format. If passed in a different format, we convert and validate the phone number against E.164. 
/// * [reference] - A reference to recognize the store by. Also known as the store code.  Allowed characters: lowercase and uppercase letters without diacritics, numbers 0 through 9, hyphen (-), and underscore (_)
/// * [shopperStatement] - The store name shown on the shopper's bank or credit card statement and on the shopper receipt.
/// * [splitConfiguration] - Rules for Adyen for Platforms merchants to split the transaction amount and fees.
/// * [status] - The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
/// * [subMerchantData] - The sub-merchant data relevant for registered payment facilitators transacting on standalone terminals.
@BuiltValue()
abstract class Store implements Built<Store, StoreBuilder> {
  /// Reference to resources connected with the store.
  @BuiltValueField(wireName: r'_links')
  Links? get links;

  /// The address of the store.
  @BuiltValueField(wireName: r'address')
  StoreLocation? get address;

  /// The unique identifiers of the [business lines](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/businesslines__resParam_id) that the store is associated with.  If not specified, the business line of the merchant account is used. Required when there are multiple business lines under the merchant account.
  @BuiltValueField(wireName: r'businessLineIds')
  BuiltList<String>? get businessLineIds;

  /// The description of the store.
  @BuiltValueField(wireName: r'description')
  String? get description;

  /// The unique identifier of the store, used by certain payment methods and tax authorities.  Required for CNPJ in Brazil, in the format 00.000.000/0000-00 separated by dots, slashes, hyphens, or without separators.  Optional for SIRET in France, up to 14 digits.  Optional for Zip in Australia, up to 50 digits.  
  @BuiltValueField(wireName: r'externalReferenceId')
  String? get externalReferenceId;

  /// The unique identifier of the store. This value is generated by Adyen.
  @BuiltValueField(wireName: r'id')
  String? get id;

  /// The localized information of the store.
  @BuiltValueField(wireName: r'localizedInformation')
  LocalizedInformation? get localizedInformation;

  /// The unique identifier of the merchant account that the store belongs to.
  @BuiltValueField(wireName: r'merchantId')
  String? get merchantId;

  /// The phone number of the store, including '+' and country code in the [E.164](https://en.wikipedia.org/wiki/E.164) format. If passed in a different format, we convert and validate the phone number against E.164. 
  @BuiltValueField(wireName: r'phoneNumber')
  String? get phoneNumber;

  /// A reference to recognize the store by. Also known as the store code.  Allowed characters: lowercase and uppercase letters without diacritics, numbers 0 through 9, hyphen (-), and underscore (_)
  @BuiltValueField(wireName: r'reference')
  String? get reference;

  /// The store name shown on the shopper's bank or credit card statement and on the shopper receipt.
  @BuiltValueField(wireName: r'shopperStatement')
  String? get shopperStatement;

  /// Rules for Adyen for Platforms merchants to split the transaction amount and fees.
  @BuiltValueField(wireName: r'splitConfiguration')
  StoreSplitConfiguration? get splitConfiguration;

  /// The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
  @BuiltValueField(wireName: r'status')
  StoreStatusEnum? get status;
  // enum statusEnum {  active,  closed,  inactive,  };

  /// The sub-merchant data relevant for registered payment facilitators transacting on standalone terminals.
  @BuiltValueField(wireName: r'subMerchantData')
  SubMerchantData? get subMerchantData;

  Store._();

  factory Store([void updates(StoreBuilder b)]) = _$Store;

  @BuiltValueHook(initializeBuilder: true)
  static void _defaults(StoreBuilder b) => b;

  @BuiltValueSerializer(custom: true)
  static Serializer<Store> get serializer => _$StoreSerializer();
}

class _$StoreSerializer implements PrimitiveSerializer<Store> {
  @override
  final Iterable<Type> types = const [Store, _$Store];

  @override
  final String wireName = r'Store';

  Iterable<Object?> _serializeProperties(
    Serializers serializers,
    Store object, {
    FullType specifiedType = FullType.unspecified,
  }) sync* {
    if (object.links != null) {
      yield r'_links';
      yield serializers.serialize(
        object.links,
        specifiedType: const FullType(Links),
      );
    }
    if (object.address != null) {
      yield r'address';
      yield serializers.serialize(
        object.address,
        specifiedType: const FullType(StoreLocation),
      );
    }
    if (object.businessLineIds != null) {
      yield r'businessLineIds';
      yield serializers.serialize(
        object.businessLineIds,
        specifiedType: const FullType(BuiltList, [FullType(String)]),
      );
    }
    if (object.description != null) {
      yield r'description';
      yield serializers.serialize(
        object.description,
        specifiedType: const FullType(String),
      );
    }
    if (object.externalReferenceId != null) {
      yield r'externalReferenceId';
      yield serializers.serialize(
        object.externalReferenceId,
        specifiedType: const FullType(String),
      );
    }
    if (object.id != null) {
      yield r'id';
      yield serializers.serialize(
        object.id,
        specifiedType: const FullType(String),
      );
    }
    if (object.localizedInformation != null) {
      yield r'localizedInformation';
      yield serializers.serialize(
        object.localizedInformation,
        specifiedType: const FullType(LocalizedInformation),
      );
    }
    if (object.merchantId != null) {
      yield r'merchantId';
      yield serializers.serialize(
        object.merchantId,
        specifiedType: const FullType(String),
      );
    }
    if (object.phoneNumber != null) {
      yield r'phoneNumber';
      yield serializers.serialize(
        object.phoneNumber,
        specifiedType: const FullType(String),
      );
    }
    if (object.reference != null) {
      yield r'reference';
      yield serializers.serialize(
        object.reference,
        specifiedType: const FullType(String),
      );
    }
    if (object.shopperStatement != null) {
      yield r'shopperStatement';
      yield serializers.serialize(
        object.shopperStatement,
        specifiedType: const FullType(String),
      );
    }
    if (object.splitConfiguration != null) {
      yield r'splitConfiguration';
      yield serializers.serialize(
        object.splitConfiguration,
        specifiedType: const FullType(StoreSplitConfiguration),
      );
    }
    if (object.status != null) {
      yield r'status';
      yield serializers.serialize(
        object.status,
        specifiedType: const FullType(StoreStatusEnum),
      );
    }
    if (object.subMerchantData != null) {
      yield r'subMerchantData';
      yield serializers.serialize(
        object.subMerchantData,
        specifiedType: const FullType(SubMerchantData),
      );
    }
  }

  @override
  Object serialize(
    Serializers serializers,
    Store object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    return _serializeProperties(serializers, object, specifiedType: specifiedType).toList();
  }

  void _deserializeProperties(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
    required List<Object?> serializedList,
    required StoreBuilder result,
    required List<Object?> unhandled,
  }) {
    for (var i = 0; i < serializedList.length; i += 2) {
      final key = serializedList[i] as String;
      final value = serializedList[i + 1];
      switch (key) {
        case r'_links':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(Links),
          ) as Links;
          result.links.replace(valueDes);
          break;
        case r'address':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(StoreLocation),
          ) as StoreLocation;
          result.address.replace(valueDes);
          break;
        case r'businessLineIds':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(BuiltList, [FullType(String)]),
          ) as BuiltList<String>;
          result.businessLineIds.replace(valueDes);
          break;
        case r'description':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.description = valueDes;
          break;
        case r'externalReferenceId':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.externalReferenceId = valueDes;
          break;
        case r'id':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.id = valueDes;
          break;
        case r'localizedInformation':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(LocalizedInformation),
          ) as LocalizedInformation;
          result.localizedInformation.replace(valueDes);
          break;
        case r'merchantId':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.merchantId = valueDes;
          break;
        case r'phoneNumber':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.phoneNumber = valueDes;
          break;
        case r'reference':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.reference = valueDes;
          break;
        case r'shopperStatement':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String;
          result.shopperStatement = valueDes;
          break;
        case r'splitConfiguration':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(StoreSplitConfiguration),
          ) as StoreSplitConfiguration;
          result.splitConfiguration.replace(valueDes);
          break;
        case r'status':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(StoreStatusEnum),
          ) as StoreStatusEnum;
          result.status = valueDes;
          break;
        case r'subMerchantData':
          final valueDes = serializers.deserialize(
            value,
            specifiedType: const FullType(SubMerchantData),
          ) as SubMerchantData;
          result.subMerchantData.replace(valueDes);
          break;
        default:
          unhandled.add(key);
          unhandled.add(value);
          break;
      }
    }
  }

  @override
  Store deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final result = StoreBuilder();
    final serializedList = (serialized as Iterable<Object?>).toList();
    final unhandled = <Object?>[];
    _deserializeProperties(
      serializers,
      serialized,
      specifiedType: specifiedType,
      serializedList: serializedList,
      unhandled: unhandled,
      result: result,
    );
    return result.build();
  }
}

class StoreStatusEnum extends EnumClass {

  /// The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
  @BuiltValueEnumConst(wireName: r'active')
  static const StoreStatusEnum active = _$storeStatusEnum_active;
  /// The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
  @BuiltValueEnumConst(wireName: r'closed')
  static const StoreStatusEnum closed = _$storeStatusEnum_closed;
  /// The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
  @BuiltValueEnumConst(wireName: r'inactive')
  static const StoreStatusEnum inactive = _$storeStatusEnum_inactive;
  /// The status of the store. Possible values are:  - **active**. This value is assigned automatically when a store is created.  - **inactive**. The terminals under the store are blocked from accepting new transactions, but capturing outstanding transactions is still possible. - **closed**. This status is irreversible. The terminals under the store are reassigned to the merchant inventory.
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const StoreStatusEnum unknownDefaultOpenApi = _$storeStatusEnum_unknownDefaultOpenApi;

  static Serializer<StoreStatusEnum> get serializer => _$storeStatusEnumSerializer;

  const StoreStatusEnum._(String name): super(name);

  static BuiltSet<StoreStatusEnum> get values => _$storeStatusEnumValues;
  static StoreStatusEnum valueOf(String name) => _$storeStatusEnumValueOf(name);
}

